#pragma once

#include <string>
#include "vector3.h"

#pragma pack(push, 1)
// struct representing the bitmap file header structure
struct BMPHeader
{
	uint8_t id_0 = 0;
	uint8_t id_1 = 0;

	uint32_t file_size = 0;

	uint16_t reserved_0 = 0;
	uint16_t reserved_1 = 0;

	uint32_t image_data_offset = 0;
};

// enum for bitmap compression formats from the bitmap header info
enum BitmapInfoHeaderCompression
{
	BI_RGB = 0,
	BI_RLE8,
	BI_RLE4,
	BI_BITFIELDS,
	BI_JPEG,
	BI_PNG,
	BI_ALPHABITFIELDS,
	BI_CMYK = 11,
	BI_CMYKRLE8,
	BI_CMYKRLE4
};

// struct representing the bitmap info header v5
struct BitmapInfoHeader
{
	uint32_t header_size = 40;

	uint32_t width_pixels;
	uint32_t height_pixels;

	uint16_t num_colour_planes;

	uint16_t num_bits_per_pixel;

	uint32_t compression_method;

	uint32_t image_size;

	uint32_t horizontal_resolution;
	uint32_t vertical_resolution;

	uint32_t num_palette_colours;

	uint32_t num_important_colours;
};
#pragma pack(pop)

// class for holding texture information (basically just the ID)
class Texture
{
private:
	// texture ID returned by opengl
	unsigned int texture_id = 0;
	// texture size
	unsigned int texture_width, texture_height;

public:
	// default constructor
	Texture();

	// load a BMP file (must be a v5 without compression) and allocate it to an openGL function. GL must be initialised before this point
	bool loadBMP(std::string path);
	// load a BMP file (must be a v5 without compression) and allocate a new CPU memory buffer for it
	static bool loadBMPRaw(std::string path, Vector3*& ptr);

	// returns the texture ID generated by openGL, or 0 if this texture has not had loadBMP called
	unsigned int getID();
	// returns the width of the texture in pixels
	unsigned int getWidth();
	// returns the height of the texture in pixels
	unsigned int getHeight();

	~Texture();
};